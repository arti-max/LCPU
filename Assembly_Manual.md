# Документация к ассемблеру для LCPU (8-битный виртуальный процессор)

## Содержание
1. [Архитектура процессора](https://github.com/arti-max/LCPU/blob/main/Assembly_Manual.md#1-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0)
2. [Список инструкций](https://github.com/arti-max/LCPU/blob/main/Assembly_Manual.md#2-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B9)
3. [Работа с регистрами](https://github.com/arti-max/LCPU/blob/main/Assembly_Manual.md#3-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D0%BC%D0%B8)
4. [Банки памяти](https://github.com/arti-max/LCPU/blob/main/Assembly_Manual.md#4-%D0%B1%D0%B0%D0%BD%D0%BA%D0%B8-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8)
5. [Директивы ассемблера](https://github.com/arti-max/LCPU/blob/main/Assembly_Manual.md#5-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0)
6. **Пример программы**
7. **Особенности работы**

---

## 1. Архитектура процессора
- **8-битная шина данных**, 16-битная адресация (до 64 КБ памяти)
- **4 банка памяти** (0-3), переключаемые через регистр BR
- **Регистры общего назначения**:
  - A, B, C (8-битные)
  - D (4-битный, старшие 4 бита игнорируются)
- **Специальные регистры**:
  - IR (Instruction Register) - текущая инструкция
  - BR (Bank Register) - активный банк памяти (2 младших бита)
  - SP (Stack Pointer) - указатель стека
  - BP (Base Pointer) - базовый указатель

---

## 2. Список инструкций

*Примечание:* после опкода всегда ставьте `,`, иначе компилятор просто не увидит операнд. Пример:
`jmp, $00  ; $ - hex число [0x00 - 0xFF]`

### Загрузка/сохранение данных
| Инструкция      | Описание                          | Байты |
|-----------------|-----------------------------------|-------|
| `ld X, value`   | Загрузить значение в регистр X   | 2     |
| `ld m, addr`    | Загрузить из памяти (A = [addr]) | 2     |
| `str m, addr`   | Сохранить в память ([addr] = A)  | 2     |
| `ld rx, [reg+o]`| Загрузка через регистр+смещение  | 3     |
| `str rx, [reg+o]`| Сохранение через регистр+смещение| 3     |

### Арифметика
| Инструкция      | Описание                          |
|-----------------|-----------------------------------|
| `add X1, X2`    | X1 = X1 + X2                      |
| `sub X1, X2`    | X1 = X1 - X2                      |
| `shl`/`shr, X`  | Сдвиг X влево/вправо              |

### Логические операции
| Инструкция      | Описание                          |
|-----------------|-----------------------------------|
| `xor X1, X2`         | X1 = X1 XOR X2               |
| `and X1, X2`         | X1 = X1 AND X2               |
| `or X1, X2`          | X1 = X1 OR X2                |
| `cmp X1, X2`         | X1 == X2?                    |

### Управление потоком
| Инструкция      | Описание                          |
|-----------------|-----------------------------------|
| `jmp, addr`      | Безусловный переход              |
| `je/jne, addr`   | Переход если равно/не равно      |
| `jg/jl, addr`    | Переход если больше/меньше       |
| `call, addr`     | Вызов подпрограммы               |
| `ret, N`         | Возврат + очистка N байт стека   |

### Стек
| Инструкция      | Описание                          |
|-----------------|-----------------------------------|
| `push, X`        | Положить регистр в стек          |
| `pop, X`         | Извлечь регистр из стека         |
| `pushr`/`popr`  | Сохранить/восстановить все регистры |

### Ввод-вывод
| Инструкция      | Описание                          |
|-----------------|-----------------------------------|
| `in P, X`       | Чтение из порта P в регистр X     |
| `out P, X`      | Запись в порт P из регистра X     |

### Специальные
| Инструкция      | Описание                          |
|-----------------|-----------------------------------|
| `swb N`         | Переключить банк памяти (0-3)     |
| `nop`           | Пустая операция                   |
| `hlt`           | Останов процессора                |

---

## 3. Работа с регистрами
- **Регистры общего назначения**:
  ```asm
  ld a, $10    ; A = 0x10
  add a, b      ; A += B
  ```
- **4-битный регистр D**:
  ```asm
  ld d, $0F    ; Корректно (младшие 4 бита)
  ld d, $1A    ; D = 0x0A (старшие биты игнорируются)
  ```
- **Специальные регистры**:
  ```asm
  mov sp, a     ; SP = A
  swb, 3        ; Активировать банк 3 (BR = 3)
  ```

---

## 4. Банки памяти
- **4 банка** (0-3), переключение через `swb` или регистр BR:
  ```asm
  swb, 2        ; Переключиться на банк 2
  mov a, [$80] ; Чтение из 0x80 в банке 2
  ```
- **Стек по умолчанию**:
  - Банк 0, адрес 0xA0 (SP инициализируется значением 0xA0)
  - В примере используется банк 3, адрес 0xFF:
  ```asm
  swb, 3
  mov sp, $FF
  ```

---

## 5. Директивы ассемблера
- **.define** - создание констант:
  ```asm
  .define MAX_VALUE $FF
  ld a, MAX_VALUE
  ```
- **.db** - резервирование данных:
  ```asm
  data_block:
    .db $01, $02, $03
  ```

---

## 6. Пример программы (пояснение)
```asm
.define BRIGHT $ff
.define ARG_1 "bp+4"  ; Аргумент 1 через BP

start:
    call, *draw_func  ; Вызов функции
    hlt

draw_func:
    push, bp
    mov bp, sp       ; Настройка фрейма
    swb, 3           ; Работа с банком 3
    mov a, [ARG_1]   ; Чтение аргумента через BP
    out 1, a         ; Вывод в порт
    pop, bp
    ret, 3           ; Возврат с очисткой стека
```

---

## 7. Особенности работы
- **MOV-инструкции** автоматически преобразуются:
  ```asm
  mov a, [bp+4] → ld ra, bp, 4
  mov d, 5     → ld d, 5
  ```
- **Стек**:
  - `push/pop` изменяют SP (декремент/инкремент)
  - `call` сохраняет адрес возврата в стеке
- **4-битные операции** с D усекают старшие биты

--- 

Для компиляции:  
`python assembler.py input.asm output.bin`
